// This file is part of Astarte.
//
// Copyright 2023 SECO Mind Srl
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

//! Contains the generated code from the ProtoBuf definitions and the implementations of those
//! types.
//!
//! All the structs and sub-modules in this module are generated by `tonic`. `Tonic` generated those
//! elements starting from the `.proto` files present in the `./proto/astarteplatform/msghub`
//! folder.

use serde::Serialize;
use std::fmt::{Display, Formatter};

include!("astarteplatform.msghub.rs");

impl Node {
    /// Create a new [Node] with the given `interfaces_json`.
    pub fn new(interfaces_json: Vec<String>) -> Self {
        Self { interfaces_json }
    }

    /// Create a new [Node] from an iterator of interfaces.
    pub fn from_interfaces<'a, I, T>(interfaces: I) -> Result<Self, serde_json::error::Error>
    where
        I: IntoIterator<Item = &'a T>,
        T: ?Sized + Serialize + 'a,
    {
        let interfaces_json = interfaces
            .into_iter()
            .map(serde_json::to_string)
            .collect::<Result<Vec<String>, serde_json::error::Error>>()?;

        Ok(Self::new(interfaces_json))
    }
}

impl InterfacesJson {
    pub fn try_from_iter<'a, I, T>(iter: I) -> Result<Self, serde_json::error::Error>
    where
        I: IntoIterator<Item = &'a T>,
        T: ?Sized + Serialize + 'a,
    {
        iter.into_iter()
            .map(serde_json::to_string)
            .collect::<Result<Vec<String>, serde_json::error::Error>>()
            .map(|interfaces_json| Self { interfaces_json })
    }
}

impl FromIterator<String> for InterfacesJson {
    fn from_iter<T: IntoIterator<Item = String>>(iter: T) -> Self {
        Self {
            interfaces_json: iter.into_iter().collect(),
        }
    }
}

impl InterfacesName {
    pub fn iter_inner(&self) -> impl Iterator<Item = &str> + Send {
        self.names.iter().map(|s| s.as_str())
    }
}

impl From<AstarteMessage> for MessageHubEvent {
    fn from(value: AstarteMessage) -> Self {
        Self {
            event: Some(message_hub_event::Event::Message(value)),
        }
    }
}

impl MessageHubEvent {
    pub fn take_message(self) -> Option<AstarteMessage> {
        self.event.and_then(|r| match r {
            message_hub_event::Event::Message(msg) => Some(msg),
            message_hub_event::Event::Error(_) => None,
        })
    }

    pub fn take_error(self) -> Option<MessageHubError> {
        self.event.and_then(|r| match r {
            message_hub_event::Event::Message(_) => None,
            message_hub_event::Event::Error(err) => Some(err),
        })
    }

    pub fn from_error<E>(error: E) -> Self
    where
        E: std::error::Error,
    {
        Self {
            event: Some(message_hub_event::Event::Error(
                MessageHubError::from_error(error),
            )),
        }
    }
}

impl std::error::Error for MessageHubError {}

impl Display for MessageHubError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.description)?;

        for s in &self.source {
            write!(f, ": {s}")?;
        }

        Ok(())
    }
}

impl MessageHubError {
    pub fn new<S>(description: S, source: Vec<String>) -> Self
    where
        S: Into<String>,
    {
        Self {
            description: description.into(),
            source,
        }
    }

    pub fn from_error<E>(error: E) -> Self
    where
        E: std::error::Error,
    {
        let description = error.to_string();
        let mut source_vec = vec![];

        // the cause need to be cast as a &dyn Error
        let mut cause: &dyn std::error::Error = &error;
        while let Some(source) = cause.source() {
            cause = source;
            source_vec.push(source.to_string());
        }

        Self {
            description,
            source: source_vec,
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn create_node_from_interface_files() {
        let device_datastream_interface = r#"{
            "interface_name": "org.astarte-platform.rust.examples.datastream.DeviceDatastream",
            "version_major": 0,
            "version_minor": 1,
            "type": "datastream",
            "ownership": "device",
            "mappings": [
                {
                    "endpoint": "/uptime",
                    "type": "string",
                    "explicit_timestamp": true
                }
            ]
        }"#;

        let server_datastream_interface = r#"{
            "interface_name": "org.astarte-platform.rust.examples.datastream.ServerDatastream",
            "version_major": 0,
            "version_minor": 1,
            "type": "datastream",
            "ownership": "server",
            "mappings": [
                {
                    "endpoint": "/some_endpoint",
                    "type": "boolean",
                    "explicit_timestamp": true
                }
            ]
        }"#;

        let interfaces_json = [device_datastream_interface, server_datastream_interface]
            .map(|s| s.to_string())
            .to_vec();

        let node = Node::new(interfaces_json.clone());

        assert_eq!(node.interfaces_json.len(), 2);

        for (interface, expected) in node.interfaces_json.iter().zip(interfaces_json.iter()) {
            assert_eq!(interface, expected);
        }
    }
}
